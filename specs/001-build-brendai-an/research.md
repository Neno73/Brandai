# Phase 0: Research & Technology Decisions

**Feature**: BrendAI - Automated Brand Merchandise Design System
**Date**: 2025-10-12
**Purpose**: Document technology choices, integration patterns, and best practices

## Technology Stack Research

### 1. Next.js 14+ App Router Architecture

**Decision**: Use Next.js 14+ with App Router (not Pages Router)

**Rationale**:
- Built-in Server Components reduce client bundle size
- Server Actions provide type-safe API endpoints without explicit route definition
- Streaming and Suspense improve perceived performance for long-running AI operations
- Vercel deployment is optimized for Next.js (zero-config)
- App Router's layout system simplifies shared UI (timers, progress indicators)

**Best Practices**:
- Use Server Components by default; mark `'use client'` only for interactivity (timers, color pickers, forms)
- Server Actions for mutations (session creation, regeneration triggers)
- API Routes for complex workflows that need explicit REST endpoints (external webhooks, admin CRUD)
- Leverage `loading.tsx` for automatic loading states during async operations
- Use `error.tsx` for error boundaries at route level

**Integration Pattern**:
```typescript
// Server Action example (app/actions/scrape.ts)
'use server'
export async function scrapeWebsite(url: string, email: string) {
  const session = await createSession(url, email)
  const brandData = await brandfetchClient.fetchBrand(url)
  const content = await firecrawlClient.scrape(url)
  return updateSession(session.id, { scraped_data: { ...brandData, ...content } })
}

// API Route example (app/api/generate-concept/route.ts)
export async function POST(request: Request) {
  const { sessionId } = await request.json()
  const session = await getSession(sessionId)
  const concept = await generateConcept(session.scraped_data)
  return Response.json({ concept })
}
```

**Alternatives Considered**:
- Pages Router: Rejected due to lack of Server Components and less ergonomic data fetching
- Express.js + React SPA: Rejected due to more complex deployment and loss of SSR benefits
- Remix: Rejected due to less mature ecosystem and Vercel optimization for Next.js

### 2. shadcn/ui Component Library

**Decision**: Use shadcn/ui for pre-built, accessible UI components with Tailwind CSS

**Rationale**:
- Copy-paste component approach (no package dependency, full control)
- Built on Radix UI primitives (accessible, keyboard navigation, ARIA attributes)
- Tailwind CSS integration (utility-first styling)
- Type-safe with TypeScript
- Customizable via CVA (class-variance-authority) for variant management
- Includes essential components: Button, Input, Card, Dialog, Table, Alert, Progress
- Theme support via CSS variables (easy to match BrendAI brand colors)
- No runtime JavaScript for most components (better performance)

**Best Practices**:
- Initialize via CLI: `npx shadcn-ui@latest init`
- Add components individually: `npx shadcn-ui@latest add button card input`
- Customize theme in `tailwind.config.ts` and `globals.css`
- Use `cn()` utility for conditional classnames (clsx + tailwind-merge)
- Create compound components by composing primitives

**Integration Pattern**:
```typescript
// components/ui/button.tsx (generated by shadcn CLI)
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

export function Button({ className, variant, size, asChild = false, ...props }: ButtonProps) {
  const Comp = asChild ? Slot : "button"
  return <Comp className={cn(buttonVariants({ variant, size, className }))} {...props} />
}

// Usage in application
import { Button } from "@/components/ui/button"

<Button variant="outline" size="lg">Regenerate Concept</Button>
```

**Component Selection for BrendAI**:
- **Button**: CTA, form submissions, regenerate actions
- **Input**: URL/email forms, color hex input, manual data entry
- **Card**: Session summaries, product cards, concept display
- **Badge**: Status indicators (scraping, concept, complete)
- **Dialog**: Confirmation modals (duplicate session, archive product)
- **Table**: Admin session list, product management
- **Progress**: Workflow progress bars (Stage 1-5), product generation
- **Alert**: Error messages, scraping failures, manual input required
- **Skeleton**: Loading states while scraping/generating
- **Separator**: Visual dividers between workflow stages

**Tailwind Configuration**:
```javascript
// tailwind.config.ts
import type { Config } from 'tailwindcss'

const config: Config = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        // ... other color tokens
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
}
```

**Alternatives Considered**:
- Material UI (MUI): Rejected due to heavy bundle size and opinionated styling
- Chakra UI: Rejected due to runtime CSS-in-JS overhead
- Ant Design: Rejected due to less modern design patterns
- Headless UI only: Rejected due to need to build all styles from scratch
- Plain Tailwind: Rejected due to lack of complex component logic (Dialog, Dropdown)

### 3. Neon Postgres Database Strategy

**Decision**: Use Neon Postgres (serverless) with single-table design and JSONB columns

**Rationale**:
- **Serverless-optimized**: Neon's architecture designed for edge/serverless (faster cold starts than traditional Postgres)
- **Automatic connection pooling**: `@neondatabase/serverless` driver handles pooling natively (no manual pgBouncer setup)
- **Branching**: Database branching for dev/staging/preview environments (Git-like workflow)
- **Vercel integration**: Accessible via Vercel dashboard as a database provider (same UI as Vercel Postgres)
- **JSONB support**: Flexible schema for scraped_data (varies by website) and product_images array
- **Cost-effective**: Free tier includes 512 MB storage, unlimited projects, autoscaling compute
- **Instant provisioning**: Create databases in <1 second (vs minutes for traditional RDS)
- **No maintenance**: Automatic scaling, backups, high availability
- **Modern developer experience**: Web SQL editor, connection pooling metrics, query insights

**Schema Design**:
```sql
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL,
  url TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('scraping', 'concept', 'motif', 'products', 'complete', 'failed')),
  scraped_data JSONB DEFAULT '{}'::jsonb,
  concept TEXT,
  motif_image_url TEXT,
  product_images JSONB DEFAULT '[]'::jsonb,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_sessions_email ON sessions(email);
CREATE INDEX idx_sessions_status ON sessions(status);
CREATE INDEX idx_sessions_created_at ON sessions(created_at DESC);

CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  base_image_url TEXT NOT NULL,
  print_zones JSONB NOT NULL, -- ['front', 'back', 'sleeves']
  constraints TEXT,
  max_colors INT DEFAULT 8,
  recommended_elements JSONB, -- ['icon', 'graphic']
  is_archived BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Seed initial 5 products
INSERT INTO products (name, base_image_url, print_zones, constraints, max_colors) VALUES
  ('T-Shirt', '/assets/product-mockups/tshirt.png', '["front", "back"]', 'Standard screen printing', 8),
  ('Hoodie', '/assets/product-mockups/hoodie.png', '["front", "back", "sleeves"]', 'No inside printing, solid cuffs, pocket max 2x2cm embroidery', 8),
  ('Mug', '/assets/product-mockups/mug.png', '["wrap"]', '360° full color print', 999),
  ('USB Stick', '/assets/product-mockups/usb.png', '["front"]', '2x2cm logo area only', 4),
  ('Socks', '/assets/product-mockups/socks.png', '["ankle"]', 'No heel/toe printing', 6);
```

**Best Practices**:
- Use parameterized queries to prevent SQL injection
- Wrap multi-step operations in transactions (e.g., session creation + initial scraping)
- Add `updated_at` trigger for automatic timestamp updates
- Use JSONB operators (`->`, `->>`, `@>`) for querying nested data
- Connection pooling: Neon driver handles automatically (no manual pool management)
- Use database branching for feature development (create branch per feature branch)

**Integration Pattern**:
```typescript
// lib/db/queries.ts
import { neon } from '@neondatabase/serverless'

const sql = neon(process.env.DATABASE_URL!)

export async function createSession(url: string, email: string) {
  const result = await sql`
    INSERT INTO sessions (email, url, status)
    VALUES (${email}, ${url}, 'scraping')
    RETURNING *
  `
  return result.rows[0]
}

export async function updateSessionScrapedData(id: string, data: any) {
  await sql`
    UPDATE sessions
    SET scraped_data = ${JSON.stringify(data)}::jsonb,
        status = 'concept',
        updated_at = NOW()
    WHERE id = ${id}
  `
}
```

**Neon-Specific Features**:
- **Database branching**: `neonctl branches create --name feature-001` creates instant copy of database
- **Autoscaling**: Compute automatically scales to zero when idle (cost savings)
- **Connection pooling metrics**: Dashboard shows active connections, query performance
- **Time Travel**: Point-in-time recovery for accidental data changes (future enhancement)

**Vercel Integration**:
1. Add Neon integration in Vercel dashboard → Integrations
2. Select project and database
3. `DATABASE_URL` automatically added to environment variables
4. Same workflow as Vercel Postgres (transparent swap)

**Alternatives Considered**:
- Vercel Postgres: Rejected in favor of Neon for better serverless optimization and database branching
- Prisma ORM: Rejected for MVP to avoid migration complexity and ORM learning curve
- Supabase: Rejected due to additional features (auth, storage) not needed; Neon is Postgres-focused
- PlanetScale: Rejected due to lack of JSONB support (MySQL-based)
- MongoDB: Rejected due to SQL familiarity and better TypeScript integration with Postgres

### 4. Brandfetch API Integration

**Decision**: Use Brandfetch API for logo, colors, and fonts extraction

**Rationale**:
- Specialized service for brand data with high accuracy
- Provides logo in multiple formats (SVG, PNG)
- Color palette extraction with hex codes
- Font identification from website
- Free tier sufficient for MVP (TBD requests/day)

**API Capabilities**:
- `/v2/brands/:domain` - Returns brand object with logo, colors, fonts
- Logo formats: SVG (preferred), PNG, JPEG
- Color palette: up to 10 colors ranked by prominence

**Best Practices**:
- Cache results in session to avoid redundant API calls
- Fallback to manual upload if API returns no logo
- Convert SVG to PNG for consistency (use sharp or canvas)
- Select top 5 colors by prominence, prioritize logo colors over website colors
- Handle rate limits with exponential backoff

**Integration Pattern**:
```typescript
// lib/services/brandfetch.ts
import Brandfetch from 'brandfetch-api' // hypothetical SDK

export async function fetchBrandData(url: string) {
  const domain = new URL(url).hostname
  const brand = await Brandfetch.getBrand(domain)

  return {
    logo: brand.logos?.[0]?.formats?.find(f => f.format === 'png')?.src || null,
    colors: brand.colors?.slice(0, 5).map(c => c.hex) || [],
    fonts: brand.fonts?.map(f => f.name) || []
  }
}
```

**Error Handling**:
- Logo not found → set `scraped_data.logo = null`, trigger manual upload UI
- Colors < 2 → set `scraped_data.colors = []`, trigger manual color picker
- API timeout (>30s) → retry once, then fallback to manual input
- Rate limit hit → queue request for retry after cooldown

**Alternatives Considered**:
- Clearbit Logo API: Rejected due to limited color/font extraction
- Custom web scraping: Rejected due to complexity and unreliability
- Manual-only input: Rejected due to poor UX and loss of automation value

### 5. Firecrawl Web Scraping

**Decision**: Use Firecrawl for homepage text content extraction

**Rationale**:
- JavaScript rendering support (handles SPAs)
- Returns clean markdown-formatted text
- Extracts meta tags, headings, paragraphs
- Configurable token limits (~500 tokens needed)
- Free tier available for MVP

**Scraping Strategy**:
- Target elements: `<title>`, `<meta name="description">`, `<h1>`, `<h2>`, first 3 `<p>` tags
- Extract approximately 500 tokens total
- Clean HTML entities and extra whitespace
- Preserve text structure for LLM analysis

**Best Practices**:
- Set timeout to 60 seconds (FR-013 requirement)
- Use headless mode for faster scraping
- Respect robots.txt (Firecrawl handles this automatically)
- Cache results to avoid redundant scrapes if user regenerates concept

**Integration Pattern**:
```typescript
// lib/services/firecrawl.ts
import FirecrawlApp from '@mendable/firecrawl-js'

const app = new FirecrawlApp({ apiKey: process.env.FIRECRAWL_API_KEY })

export async function scrapeHomepage(url: string) {
  const result = await app.scrapeUrl(url, {
    formats: ['markdown'],
    onlyMainContent: true,
    timeout: 60000
  })

  // Parse markdown for key elements
  const lines = result.markdown.split('\n')
  const h1 = lines.find(l => l.startsWith('# '))?.replace('# ', '') || ''
  const h2s = lines.filter(l => l.startsWith('## ')).slice(0, 3)
  const paragraphs = lines.filter(l => l.length > 50 && !l.startsWith('#')).slice(0, 3)

  return {
    title: result.metadata.title || h1,
    description: result.metadata.description || paragraphs[0] || '',
    headings: [h1, ...h2s.map(h => h.replace('## ', ''))],
    content: paragraphs.join('\n\n'),
    tokens: estimateTokens(result.markdown)
  }
}

function estimateTokens(text: string): number {
  return Math.ceil(text.split(/\s+/).length * 1.3) // rough GPT token estimate
}
```

**Error Handling**:
- URL unreachable → return error, prompt user to check URL
- Timeout (>60s) → extend to 90s, then fail with manual input option
- Empty content → fall back to meta tags only, allow manual text input
- JavaScript required but failed → retry with different rendering mode

**Alternatives Considered**:
- Puppeteer/Playwright: Rejected due to complexity and cold start issues on serverless
- Cheerio: Rejected due to lack of JavaScript rendering
- Scrapy: Rejected due to Python dependency (Next.js is Node.js)

### 6. Google Gemini AI Integration

**Decision**: Use Gemini Flash/Pro for text (concept) and Gemini 2.5 Flash Image (Nano Banana) for images

**Rationale**:
- Single provider simplifies API key management
- Gemini Flash: Fast text generation (<20s), good for creative writing
- Gemini 2.5 Flash Image: Supports image input + generation, needed for "design in style of logo"
- Free tier quotas sufficient for MVP (TBD requests/day)
- Multimodal support: can accept logo image as input for motif generation

**Text Generation (Concept)**:
- Model: `gemini-1.5-flash` or `gemini-1.5-pro`
- Input: Scraped data (text, colors, fonts, logo description)
- Output: 2-3 paragraphs of brand essence + prominent theme identification
- Temperature: 0.7 (balanced creativity and coherence)
- Max tokens: 500

**Image Generation (Motif & Products)**:
- Model: `gemini-2.5-flash-image`
- Motif: Single call generates 6 elements in one image
- Products: 5 separate calls, each receives motif image + product constraints
- Input format: Base64-encoded logo + hex colors + text prompt
- Output format: PNG image URL

**Best Practices**:
- Use structured prompts with clear constraints (colors, style, vectorizable)
- Include logo image as reference for style consistency
- Retry once on failure with same prompt (non-deterministic AI)
- Cache concept text for regeneration comparison (avoid identical outputs)
- Log prompts and responses for debugging AI quality issues

**Integration Pattern**:
```typescript
// lib/services/gemini-text.ts
import { GoogleGenerativeAI } from '@google/generative-ai'

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!)
const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })

export async function generateConcept(scrapedData: any) {
  const prompt = `
Analyze this brand data and create a creative concept for merchandise designs:

Website: ${scrapedData.content}
Colors: ${scrapedData.colors.join(', ')}
Fonts: ${scrapedData.fonts.join(', ')}
Tone: ${scrapedData.description}

Generate:
1. A 2-3 paragraph creative concept describing the brand essence and merchandise direction
2. Identify the most prominent theme (e.g., sustainability, innovation, milestone celebration)

Format as:
[2-3 paragraphs]

Prominent Theme: [theme name]
`

  const result = await model.generateContent(prompt)
  return result.response.text()
}

// lib/services/gemini-image.ts
export async function generateMotif(scrapedData: any, conceptText: string) {
  const prompt = `
Design 6 complementary brand elements in the style of the provided logo, using colors: ${scrapedData.colors.join(', ')}.

Creative concept: ${conceptText}

Requirements:
- 6 distinct elements arranged in a grid (2x3 or 3x2)
- Flat design, vector-friendly (no gradients, no photos)
- Mix of icons, geometric patterns, abstract shapes
- Suitable for screen printing and embroidery
- Elements work individually or combined
- Various scales (some for small items, some for large)

Logo style analysis: [match line weight, complexity, mood from attached logo]
`

  const imagePart = {
    inlineData: {
      data: Buffer.from(scrapedData.logo).toString('base64'),
      mimeType: 'image/png'
    }
  }

  const result = await model.generateContent([prompt, imagePart])
  return result.response.image() // returns image URL or base64
}
```

**Prompt Engineering Strategy**:
- Concept prompt: Emphasize "merchandise-focused" to avoid generic brand descriptions
- Motif prompt: Specify "6 elements in single image" to ensure family consistency
- Product prompts: Include specific constraints per product (print zones, color limits, size)
- Use few-shot examples if initial outputs don't meet quality bar

**Error Handling**:
- Content policy violation → retry with softened prompt (e.g., remove specific brand names)
- Timeout (>20s for concept, >60s for motif) → retry once, then fail with error message
- Invalid output format → parse with fallbacks, log for manual review
- Quota exceeded → display user-friendly error, log for quota increase decision

**Alternatives Considered**:
- OpenAI GPT-4 + DALL-E 3: Rejected due to separate text/image APIs and higher cost
- Anthropic Claude + Midjourney: Rejected due to Midjourney's lack of programmatic API
- Stability AI (Stable Diffusion): Rejected due to lower style consistency and prompt complexity

### 7. Resend Email Delivery

**Decision**: Use Resend for transactional email with PDF attachments

**Rationale**:
- Vercel-native integration (one-click setup)
- Free tier: 100 emails/day (sufficient for MVP)
- React Email component support for HTML templates
- Automatic retry logic built-in
- High deliverability rates

**Email Strategy**:
- **Completion email**: PDF attachment + magic link + brief intro
- **Recovery email**: Magic link + progress indicator (24hr delay)
- Subject lines: Personalized with company name extracted from scraping
- From: `noreply@brendai.com` (or Resend sandbox domain for MVP)

**Best Practices**:
- Use React Email templates for consistent branding
- Attach PDF as `brand-kit-[company-name].pdf`
- Include plain text version for email clients without HTML support
- Magic link format: `https://brendai.com/session/[uuid]`
- Track delivery status via Resend webhooks (log to sessions table)

**Integration Pattern**:
```typescript
// lib/services/email.ts
import { Resend } from 'resend'

const resend = new Resend(process.env.RESEND_API_KEY)

export async function sendBrandKitEmail(session: any, pdfBuffer: Buffer) {
  const companyName = extractCompanyName(session.scraped_data.title)
  const magicLink = `${process.env.NEXT_PUBLIC_BASE_URL}/session/${session.id}`

  await resend.emails.send({
    from: 'BrendAI <noreply@brendai.com>',
    to: session.email,
    subject: `Your ${companyName} Brand Merchandise Kit is Ready`,
    html: `
      <h1>Your brand kit is ready!</h1>
      <p>We've created a custom merchandise visualization for ${companyName}.</p>
      <p>Your PDF is attached, and you can view/edit online: <a href="${magicLink}">Open Brand Kit</a></p>
    `,
    attachments: [
      {
        filename: `brand-kit-${companyName.toLowerCase().replace(/\s+/g, '-')}.pdf`,
        content: pdfBuffer
      }
    ]
  })
}

export async function sendRecoveryEmail(session: any) {
  const magicLink = `${process.env.NEXT_PUBLIC_BASE_URL}/session/${session.id}`
  const progress = calculateProgress(session.status) // 'concept' = 40%, 'motif' = 60%

  await resend.emails.send({
    from: 'BrendAI <noreply@brendai.com>',
    to: session.email,
    subject: `Your brand kit is ${progress}% complete - finish designing →`,
    html: `
      <h1>You're almost done!</h1>
      <p>Your brand kit is ${progress}% complete. Finish designing to see your mockups.</p>
      <p><a href="${magicLink}">Continue Designing →</a></p>
    `
  })
}
```

**Error Handling**:
- Delivery failure → log error, retry after 5 minutes (FR-086)
- Recipient invalid email → display error to user during form submission
- Attachment too large → compress PDF or remove images, fallback to magic link only
- Rate limit hit → queue email for delayed send

**Alternatives Considered**:
- SendGrid: Rejected due to more complex setup and less Vercel integration
- AWS SES: Rejected due to configuration complexity for MVP
- Mailgun: Rejected due to lower free tier limits

### 8. React PDF Generation

**Decision**: Use `@react-pdf/renderer` for PDF presentation

**Rationale**:
- React-based: familiar component syntax
- Server-side rendering (Node.js compatible)
- Supports images, custom fonts, layouts
- Generates PDF buffer (no external service needed)
- Open source, no API limits

**PDF Structure (7 sections)**:
1. Cover: BrendAI logo + client logo + title
2. Brand Analysis: Color swatches + fonts + sentiment summary
3. Creative Concept: Text with decorative elements
4. Motif Showcase: 6 elements grid + rationale text
5. Product Gallery: 5 mockups in 2x3 grid (or 3x2)
6. Brand Guidelines: Color codes table + usage instructions
7. Next Steps: CTA with contact info

**Best Practices**:
- Load images as base64 or URLs (no relative paths)
- Use system fonts or embed custom fonts
- Keep PDF under 5MB for email attachment limits
- Generate in memory (buffer), don't write to disk
- Add metadata (title, author, subject)

**Integration Pattern**:
```typescript
// lib/services/pdf-generator.ts
import ReactPDF, { Document, Page, Text, Image, View, StyleSheet } from '@react-pdf/renderer'

const styles = StyleSheet.create({
  page: { padding: 40, fontFamily: 'Helvetica' },
  cover: { textAlign: 'center', marginBottom: 20 },
  section: { marginBottom: 30 },
  colorSwatch: { width: 50, height: 50, marginRight: 10 }
})

export async function generatePresentation(session: any) {
  const MyDocument = (
    <Document>
      <Page style={styles.page}>
        {/* Cover */}
        <View style={styles.cover}>
          <Image src="/assets/branding/brendai-logo.png" style={{ width: 200 }} />
          <Text style={{ fontSize: 24, marginTop: 20 }}>
            {extractCompanyName(session.scraped_data.title)} Brand Kit
          </Text>
        </View>
      </Page>

      <Page style={styles.page}>
        {/* Brand Analysis */}
        <View style={styles.section}>
          <Text style={{ fontSize: 18, marginBottom: 10 }}>Brand Analysis</Text>
          <View style={{ flexDirection: 'row' }}>
            {session.scraped_data.colors.map((color: string) => (
              <View key={color} style={[styles.colorSwatch, { backgroundColor: color }]} />
            ))}
          </View>
        </View>
      </Page>

      {/* Additional pages for concept, motif, products, guidelines, CTA */}
    </Document>
  )

  const buffer = await ReactPDF.renderToBuffer(MyDocument)
  return buffer
}
```

**Error Handling**:
- Image load failure → use placeholder or skip image
- Generation timeout (>20s) → retry once, extend to 60s (FR-090)
- Out of memory → reduce image quality or dimensions
- Invalid PDF structure → log error, return fallback template

**Alternatives Considered**:
- Puppeteer/Playwright PDF export: Rejected due to cold start issues and resource usage
- PDFKit: Rejected due to lower-level API and less React-friendly
- External PDF service (CloudConvert): Rejected due to API costs and latency

### 9. Image Storage Strategy

**Decision**: Use Vercel Blob Storage for generated images (logo, motif, product mockups)

**Rationale**:
- Native Vercel integration (same deployment pipeline)
- CDN-backed for fast delivery
- Supports direct upload from server functions
- Automatic HTTPS URLs for database storage
- Pay-as-you-go pricing (cost-effective for MVP scale)

**Storage Organization**:
```
/sessions/[sessionId]/
  ├── logo.png              # Processed logo
  ├── motif.png             # 6-element motif
  ├── product-tshirt.png    # T-shirt mockup
  ├── product-hoodie.png    # Hoodie mockup
  ├── product-mug.png       # Mug mockup
  ├── product-usb.png       # USB mockup
  └── product-socks.png     # Socks mockup
```

**Best Practices**:
- Generate unique paths per session to avoid collisions
- Set appropriate Content-Type headers (image/png)
- Enable CDN caching (Cache-Control: max-age=31536000)
- Store URLs in database, not raw image data
- Implement cleanup job for abandoned sessions (future enhancement)

**Integration Pattern**:
```typescript
// lib/utils/image-storage.ts
import { put } from '@vercel/blob'

export async function uploadImage(sessionId: string, filename: string, buffer: Buffer) {
  const blob = await put(`sessions/${sessionId}/${filename}`, buffer, {
    access: 'public',
    contentType: 'image/png'
  })

  return blob.url // Store this in database
}

export async function uploadLogoFromUrl(sessionId: string, logoUrl: string) {
  const response = await fetch(logoUrl)
  const buffer = Buffer.from(await response.arrayBuffer())
  const processed = await convertToPng(buffer) // lib/utils/image-processing.ts
  return uploadImage(sessionId, 'logo.png', processed)
}
```

**Error Handling**:
- Upload failure → retry once, then fail with error
- Storage quota exceeded → display error, block new sessions
- Invalid image format → attempt conversion, otherwise reject

**Alternatives Considered**:
- AWS S3: Rejected due to more complex setup and separate billing
- Cloudinary: Rejected due to free tier limits and transformation costs
- Local filesystem: Rejected due to serverless ephemeral storage

### 10. Magic Link Authentication

**Decision**: Use signed JWTs for magic link tokens (no user passwords)

**Rationale**:
- No user authentication system needed (sessions are public via link)
- JWT signing ensures link integrity (can't be forged)
- Stateless: no session store needed
- No expiration in MVP (as per requirements)
- Simple implementation with `jsonwebtoken` library

**Token Structure**:
```json
{
  "sessionId": "uuid",
  "email": "user@example.com",
  "iat": 1234567890
}
```

**Best Practices**:
- Sign with `HS256` algorithm using `MAGIC_LINK_SECRET` env var
- Validate signature on every session page load
- Include email in token for auditing (optional verification)
- Use URL-safe encoding (base64url)
- No expiration (exp claim) for MVP

**Integration Pattern**:
```typescript
// lib/utils/magic-link.ts
import jwt from 'jsonwebtoken'

const SECRET = process.env.MAGIC_LINK_SECRET!

export function generateMagicLink(sessionId: string, email: string): string {
  const token = jwt.sign({ sessionId, email }, SECRET, { algorithm: 'HS256' })
  return `${process.env.NEXT_PUBLIC_BASE_URL}/session/${sessionId}?token=${token}`
}

export function validateMagicLink(sessionId: string, token: string): boolean {
  try {
    const decoded = jwt.verify(token, SECRET) as any
    return decoded.sessionId === sessionId
  } catch {
    return false
  }
}

// Simpler approach for MVP: no token query param, just sessionId
// Anyone with URL can access (acceptable for MVP lead gen use case)
export function getSessionUrl(sessionId: string): string {
  return `${process.env.NEXT_PUBLIC_BASE_URL}/session/${sessionId}`
}
```

**Security Considerations**:
- Sessions contain no sensitive data (public brand information)
- Email addresses are exposed but acceptable for lead gen context
- No PII beyond email address
- Future: Add expiration (7 days) and refresh logic for production

**Alternatives Considered**:
- Database-backed tokens: Rejected due to unnecessary complexity for MVP
- Encrypted URLs: Rejected due to decryption overhead
- No authentication: Selected for MVP simplicity (sessionId alone is sufficient)

### 11. Admin Authentication

**Decision**: Hardcoded email/password for admin panel (bcrypt-hashed password)

**Rationale**:
- Single admin user in MVP (no multi-tenant support)
- Simple middleware-based route protection
- No user management UI needed
- Password stored as bcrypt hash in env var (not plaintext)
- Session cookie for authenticated state

**Authentication Flow**:
1. Admin navigates to `/admin` → redirected to `/admin/login`
2. Submits email + password
3. Server validates against env vars (`ADMIN_EMAIL`, `ADMIN_PASSWORD_HASH`)
4. Sets HTTP-only cookie with session token
5. Middleware checks cookie on all `/admin/*` routes

**Best Practices**:
- Use bcrypt for password hashing (even for single user)
- HTTP-only, Secure, SameSite cookies
- CSRF protection via Next.js built-in middleware
- Logout endpoint clears cookie

**Integration Pattern**:
```typescript
// app/admin/login/route.ts
import bcrypt from 'bcryptjs'
import { cookies } from 'next/headers'

export async function POST(request: Request) {
  const { email, password } = await request.json()

  const isValid =
    email === process.env.ADMIN_EMAIL &&
    await bcrypt.compare(password, process.env.ADMIN_PASSWORD_HASH!)

  if (!isValid) {
    return Response.json({ error: 'Invalid credentials' }, { status: 401 })
  }

  // Set session cookie
  cookies().set('admin_session', 'authenticated', {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 60 * 60 * 24 // 24 hours
  })

  return Response.json({ success: true })
}

// middleware.ts
import { NextResponse } from 'next/server'

export function middleware(request: Request) {
  const cookie = request.cookies.get('admin_session')

  if (request.url.startsWith('/admin') && cookie?.value !== 'authenticated') {
    return NextResponse.redirect(new URL('/admin/login', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: '/admin/:path*'
}
```

**Error Handling**:
- Invalid credentials → display error, allow retry
- Cookie expired → redirect to login
- Missing env vars → fail fast on app startup

**Alternatives Considered**:
- NextAuth.js: Rejected due to overkill for single user
- Magic link for admin: Rejected due to added complexity
- No authentication: Rejected due to security requirements (FR-074, FR-075)

## Integration Patterns Summary

### Workflow Orchestration

**End-to-End Flow (Stages 1-5)**:
```
User submits URL + email
  ↓
POST /api/scrape → Brandfetch + Firecrawl in parallel
  ↓
Database: Create session with scraped_data
  ↓
Redirect to /session/[id] → Display Stage 2 (Concept Review)
  ↓
User waits 3 mins or clicks "Proceed"
  ↓
POST /api/generate-concept → Gemini text generation
  ↓
Database: Update session with concept
  ↓
Display Stage 3 (Motif Review)
  ↓
POST /api/generate-motif → Gemini Image (1 call, 6 elements)
  ↓
Database: Update session with motif_image_url
  ↓
Display Stage 4 (Product Generation) with progress bar
  ↓
POST /api/generate-products → 5 sequential Gemini Image calls
  ↓
Database: Update session with product_images array
  ↓
POST /api/create-presentation → React PDF generation
  ↓
POST /api/send-email → Resend with PDF + magic link
  ↓
Display success message + immediate magic link access
```

**Error Recovery Strategy**:
- Each stage is idempotent (can retry without duplication)
- Session status field tracks progress for recovery
- Failed stages display retry button
- Partial failures (e.g., 4/5 products generated) still proceed
- Email failure doesn't block UI (magic link shown immediately)

### State Management

**Client State**:
- React Context for session data (shared across pages)
- Local storage for countdown timer persistence
- SWR for data fetching with automatic revalidation

**Server State**:
- Database as source of truth
- No in-memory caching (serverless functions are ephemeral)
- Session status as finite state machine

**State Transitions**:
```
scraping → concept → motif → products → complete
     ↓         ↓        ↓         ↓         ↓
  failed    failed   failed    failed    failed
```

## Development Best Practices

### Error Handling Patterns

1. **API Route Errors**:
```typescript
try {
  const result = await externalAPI()
  return Response.json({ data: result })
} catch (error) {
  console.error('API error:', error)
  return Response.json(
    { error: 'User-friendly message', details: error.message },
    { status: 500 }
  )
}
```

2. **Server Action Errors**:
```typescript
'use server'
export async function myAction() {
  try {
    const result = await operation()
    return { success: true, data: result }
  } catch (error) {
    return { success: false, error: error.message }
  }
}
```

3. **Component Error Boundaries**:
```typescript
// app/error.tsx
'use client'
export default function Error({ error, reset }: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```

### Testing Strategy

**Unit Tests** (Vitest):
- Service functions (brandfetch, gemini, pdf-generator)
- Utility functions (validation, magic-link, image-processing)
- Database queries (mock SQL client)

**Integration Tests**:
- API routes with mocked external APIs
- Database operations with test database
- Workflow orchestration (multi-step flows)

**E2E Tests** (Playwright via MCP):
- Complete user flow: landing → scraping → concept → motif → products → email
- Regeneration flows (concept, motif)
- Admin product management
- Error scenarios (failed scraping, API timeouts)

**Test Coverage Goals**:
- Services: 80%+ (critical business logic)
- API routes: 70%+ (happy path + error handling)
- Components: 60%+ (interaction logic)

### Environment Variables

**Required for MVP**:
```env
# Database
POSTGRES_URL=postgres://...

# External APIs
BRANDFETCH_API_KEY=...
FIRECRAWL_API_KEY=...
GEMINI_API_KEY=...
RESEND_API_KEY=...

# Storage
BLOB_READ_WRITE_TOKEN=...

# Authentication
MAGIC_LINK_SECRET=random-256-bit-hex
ADMIN_EMAIL=admin@brendai.com
ADMIN_PASSWORD_HASH=bcrypt-hash-here

# App Config
NEXT_PUBLIC_BASE_URL=https://brendai.vercel.app
NODE_ENV=production
```

**Local Development**:
```env
NEXT_PUBLIC_BASE_URL=http://localhost:3000
NODE_ENV=development
```

### Performance Optimizations

**Image Optimization**:
- Use Next.js `<Image>` component for automatic optimization
- Lazy load product mockups (below fold)
- WebP format with PNG fallback
- Responsive images (srcset)

**API Response Times**:
- Parallel scraping (Brandfetch + Firecrawl)
- Stream product generation updates to client
- Background email sending (don't block UI)

**Database Optimization**:
- Index on email, status, created_at (frequent queries)
- JSONB GIN indexes for scraped_data queries (if needed)
- Connection pooling via @vercel/postgres

**Client Bundle Size**:
- Server Components for static UI
- Dynamic imports for heavy components (color picker, PDF viewer)
- Tree shaking unused libraries

## Deployment Considerations

**Vercel Configuration** (`vercel.json`):
```json
{
  "buildCommand": "next build",
  "outputDirectory": ".next",
  "framework": "nextjs",
  "regions": ["iad1"],
  "env": {
    "POSTGRES_URL": "@postgres-url",
    "BRANDFETCH_API_KEY": "@brandfetch-key"
  },
  "functions": {
    "app/api/generate-products/route.ts": {
      "maxDuration": 300
    }
  }
}
```

**Function Timeouts**:
- Default: 10s (sufficient for most routes)
- `/api/generate-products`: 300s (5 minutes for 5 AI calls)
- `/api/scrape`: 90s (extended timeout for slow websites)

**Cold Start Mitigation**:
- Keep functions warm with cron job (future enhancement)
- Minimize dependencies in API routes
- Use Edge Functions for simple routes (admin login, magic link validation)

## Security Considerations

**API Key Management**:
- Store in Vercel environment variables (encrypted)
- Never commit to Git
- Rotate keys quarterly (production best practice)

**Input Validation**:
- Zod schemas for all user inputs
- URL validation (prevent SSRF attacks)
- Email validation (prevent injection)
- File upload restrictions (size, type)

**Rate Limiting**:
- Vercel Edge Config for rate limit tracking (future enhancement)
- Per-IP limits on form submissions
- Per-email limits on session creation (prevent spam)

**CORS**:
- Restrict to same-origin for MVP
- Add explicit CORS headers if external integrations needed

**Content Security Policy**:
- Restrict image sources to trusted CDNs
- No inline scripts (Next.js default)
- Frame ancestors: 'none' (prevent clickjacking)

## Monitoring & Observability

**Logging Strategy**:
- Vercel Logs for request/response tracking
- Console.error for exceptions (captured by Vercel)
- Structured logging for key events:
  - Session creation
  - API call durations
  - AI generation failures
  - Email delivery status

**Metrics to Track**:
- Session completion rate (scraping → complete)
- Average workflow duration
- AI generation success rate
- Email delivery success rate
- Error rates per stage

**Alerting** (Future):
- Slack webhook for critical errors
- Email alert for rate limit hits
- Dashboard for session monitoring

## Conclusion

All technology decisions are finalized based on the provided tech stack guidance and feature requirements. The architecture leverages:

- **Frontend**: Next.js 14+ App Router with shadcn/ui components and Tailwind CSS for a modern, accessible UI
- **Backend**: Server Actions and API Routes for type-safe mutations and complex workflows
- **Database**: Neon Postgres (serverless) for instant provisioning, autoscaling, and database branching
- **Integrations**: Brandfetch (brand extraction), Firecrawl (web scraping), Google Gemini (AI generation), Resend (email delivery)
- **Storage**: Vercel Blob for generated images

The complete stack is serverless-first, optimized for Vercel deployment, and provides excellent developer experience with TypeScript throughout. shadcn/ui brings pre-built accessible components with full customization control, while Neon Postgres offers superior serverless performance over traditional databases.

No unresolved clarifications remain - implementation can proceed directly to Phase 1 (data modeling and API contracts).

**Next Steps**:
- Phase 1: Generate `data-model.md` from Key Entities
- Phase 1: Generate `contracts/api-routes.yaml` from Functional Requirements
- Phase 1: Generate `quickstart.md` for developer onboarding
- Phase 1: Update agent context with technology stack
